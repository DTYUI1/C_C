
## Описание: в ходе работы я (Ярик) написал несколько ридмишек, для каждого задания есть свой readme файл, либо с описанием шагов, либо с ответом на доп. задание (как допустим в readme3.md). Приятного утра, дня, вечера вам, Руслан Георгиевич! ( • ᴗ - ) ✧

# 1. Разобраться, как static, extern, глобальные переменные влияют на линковку.

    Static озночает что переменная принадлежит только конкретному файлу и на этапе линковки такие переменные не имеют смысла (т.к. их не с кем связывать). 
    Extert берёт переменную из какого-то другого файла (тем самым помечаю компоновщику что откуда-то надо будет его привязать во время линковки).
    Глобальные переменные же на этапе линковки играют одну из ключевых ролей, т.к. именно их линковщик подключает для всех файлов. И если в другом файле будет данная переменная, то она сможет быть использована.

# 2. Научиться исследовать объектные файлы (.o) через nm, objdump, strings.

    В ходе работы я научился иследовать объектные файлы. 
    nm - Я использовал утилиту nm тем самым я отображал таблицу символов объектного файла. В ней указан адрес символа, тип символа и имя символа ("символ" - различные переменные, функции, метки, секции кода и данных, и т.д.). Тем самым он позволяет анализировать объектники и позволяет лучше понять как будет происходить этап линковки.
    Кстати, вот различные типы символов => T (код, глобальный), t (код, локальный), D (иниц. данные, глобальные), d (иниц. данные, локальные), B (неиниц. данные, глобальные), b (неиниц. данные, локальные), U (неопределённый), C (общий), R (данные только для чтения, глобальные), r (данные только для чтения, локальные), A (абсолютный), W/w (слабый символ), V/v (слабый объект), I (косвенный).
    objdump - Я использовол objdump для исследования объектного файла, в часности для анализа бинарного представления файла (обычно в elf) и изучение того на что адресуется каждая ячейка файла. В отличие от других утилит (кроме xxd), выводит гораздо больше информации. 
    strings — утилита, которая ищет и выводит последовательности печатных символов в файлах, помогая очень быстро найти строковые константы, отладочную информацию и позволяет примерно понять назначение программы. Также в отличие от других утилит она не выводит адреса ячеек памяти. (*_*)

# 3. Понять, как gcc выполняет статическое связывание.

    По своей сути gcc при выполнение статической линковки связывает объектные файлы и необходимые в коде статические библиотеки (.a) в один исполняемый файл. Тем самым библиотеки не будут подгружаться динамически во время работы программы, а будут уже добавлены на этапе связывания. Опция для статического связывания "-static". :З

## ᓚ₍ ^. .^₎